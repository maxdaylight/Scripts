# =============================================================================
# Script: Analyze-MSRDCollectOutput.ps1
# Author: maxdaylight
# Last Updated: 2025-09-17 18:03:31 UTC
# Updated By: maxdaylight
# Version: 2.1.0
# Additional Info: Added storage/disk health analysis, SMB connectivity checks, and true UTC timestamps in reports
# =============================================================================

<#
.SYNOPSIS
Analyzes the output from MSRD-Collect.ps1 diagnostic tool to identify common Remote Desktop and Azure Virtual Desktop issues.

.DESCRIPTION
This script processes the comprehensive diagnostic data collected by MSRD-Collect.ps1,
analyzing logs, registry entries, event logs, system information, AVD-specific diagnostics,
FSLogix profiles, certificates, MDM policies, and HTML diagnostic reports to identify
common Remote Desktop Services and Azure Virtual Desktop issues, configuration problems,
and potential solutions.

The script generates detailed summary reports highlighting critical findings, warnings,
recommendations, and provides actionable troubleshooting steps for Remote Desktop and AVD environments.

Key Analysis Areas:
- Azure Virtual Desktop (AVD) specific diagnostics
- FSLogix profile container issues
- Event log analysis with pattern detection
- Registry configuration validation
- Network connectivity and firewall analysis
- Certificate validation and expiration
- System performance and resource utilization
- Service status and dependency analysis
- User profile and session management
- HTML diagnostic report integration

.PARAMETER MSRDOutputPath
The path to the MSRD-Collect output directory containing diagnostic files.

.PARAMETER ReportPath
The path where the analysis report will be saved. Defaults to script directory.

.PARAMETER DaysToAnalyze
Number of days of event logs to analyze. Defaults to 7 days.

.PARAMETER IncludeDetailedLogs
Include detailed log analysis in the output report.

.PARAMETER ExportToCSV
Export findings to CSV format for further analysis.

.PARAMETER AnalyzeHtmlReports
Parse and analyze HTML diagnostic reports generated by MSRD-Collect.

.PARAMETER IncludeAVDAnalysis
Include Azure Virtual Desktop specific analysis (enabled by default).

.PARAMETER IncludeFSLogixAnalysis
Include FSLogix profile container analysis (enabled by default).

.PARAMETER Verbose
Enable verbose output for detailed processing information.

.EXAMPLE
.\Analyze-MSRDCollectOutput.ps1 -MSRDOutputPath "C:\MSRD-Results-Computer-20250710_133757" -ReportPath "C:\Reports"
Analyzes MSRD-Collect output and generates a comprehensive report with all analysis modules.

.EXAMPLE
.\Analyze-MSRDCollectOutput.ps1 -MSRDOutputPath "C:\MSRD-Results-Computer-20250710_133757" -DaysToAnalyze 14 -IncludeDetailedLogs -ExportToCSV -AnalyzeHtmlReports
Analyzes 14 days of data with detailed logs, CSV export, and HTML report analysis.

.EXAMPLE
.\Analyze-MSRDCollectOutput.ps1 -MSRDOutputPath "C:\MSRD-Results-Computer-20250710_133757" -IncludeAVDAnalysis -IncludeFSLogixAnalysis -Verbose
Focuses on AVD and FSLogix analysis with verbose output for troubleshooting.
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory = $true, HelpMessage = "Path to MSRD-Collect output directory")]
    [ValidateScript({ Test-Path -Path $_ -PathType Container })]
    [string]$MSRDOutputPath,

    [Parameter(Mandatory = $false, HelpMessage = "Path for analysis reports")]
    [string]$ReportPath = $PSScriptRoot,

    [Parameter(Mandatory = $false, HelpMessage = "Number of days of event logs to analyze")]
    [ValidateRange(1, 365)]
    [int]$DaysToAnalyze = 7,

    [Parameter(Mandatory = $false, HelpMessage = "Include detailed log analysis")]
    [switch]$IncludeDetailedLogs,

    [Parameter(Mandatory = $false, HelpMessage = "Export findings to CSV")]
    [switch]$ExportToCSV,

    [Parameter(Mandatory = $false, HelpMessage = "Parse and analyze HTML diagnostic reports")]
    [switch]$AnalyzeHtmlReports,

    [Parameter(Mandatory = $false, HelpMessage = "Include Azure Virtual Desktop specific analysis")]
    [switch]$IncludeAVDAnalysis,

    [Parameter(Mandatory = $false, HelpMessage = "Include FSLogix profile container analysis")]
    [switch]$IncludeFSLogixAnalysis,

    [Parameter(Mandatory = $false, HelpMessage = "Force overwrite existing reports")]
    [switch]$Force
    ,
    [Parameter(Mandatory = $false, HelpMessage = "Minimum free percent required on system drive (C:)")]
    [ValidateRange(1, 100)]
    [int]$MinSystemDriveFreePercent = 15,

    [Parameter(Mandatory = $false, HelpMessage = "Minimum free GB required on temp/system drive areas")]
    [ValidateRange(0, 2048)]
    [int]$MinTempFreeGB = 5
)

# Script-level variables
$script:MSRDOutputPath          = $MSRDOutputPath
$script:ReportPath              = $ReportPath
$script:DaysToAnalyze           = $DaysToAnalyze
$script:IncludeDetailedLogs     = $IncludeDetailedLogs
$script:ExportToCSV             = $ExportToCSV
$script:AnalyzeHtmlReports      = $AnalyzeHtmlReports
$script:IncludeAVDAnalysis      = if ($PSBoundParameters.ContainsKey('IncludeAVDAnalysis')) { $IncludeAVDAnalysis } else { $true }
$script:IncludeFSLogixAnalysis  = if ($PSBoundParameters.ContainsKey('IncludeFSLogixAnalysis')) { $IncludeFSLogixAnalysis } else { $true }
$script:Force                   = $Force
$script:MinSystemDriveFreePercent = $MinSystemDriveFreePercent
$script:MinTempFreeGB             = $MinTempFreeGB

# Initialize arrays for findings
$script:CriticalIssues   = @()
$script:Warnings         = @()
$script:Recommendations  = @()
$script:DetailedFindings = @()
$script:AVDFindings      = @()
$script:FSLogixFindings  = @()
$script:PerformanceIssues = @()
$script:SecurityFindings = @()
$script:DiskFindings     = @()
$script:DiskEventDetails = @()

# Global variables for directory paths
$script:ComputerName     = ""
$script:EventLogsPath    = ""
$script:RegistryPath     = ""
$script:SystemInfoPath   = ""
$script:NetworkingPath   = ""
$script:AVDPath          = ""
$script:ProfilesPath     = ""
$script:CertificatesPath = ""
$script:MDMPath          = ""
$script:IMEPath          = ""

# Define PowerShell version-specific color support
$script:UseAnsiColors = $PSVersionTable.PSVersion.Major -ge 7
$script:Colors        = @{
    'Red'      = if ($script:UseAnsiColors) { "`e[31m" } else { [System.ConsoleColor]::Red }
    'Green'    = if ($script:UseAnsiColors) { "`e[32m" } else { [System.ConsoleColor]::Green }
    'Yellow'   = if ($script:UseAnsiColors) { "`e[33m" } else { [System.ConsoleColor]::Yellow }
    'Blue'     = if ($script:UseAnsiColors) { "`e[34m" } else { [System.ConsoleColor]::Blue }
    'Magenta'  = if ($script:UseAnsiColors) { "`e[35m" } else { [System.ConsoleColor]::Magenta }
    'Cyan'     = if ($script:UseAnsiColors) { "`e[36m" } else { [System.ConsoleColor]::Cyan }
    'White'    = if ($script:UseAnsiColors) { "`e[37m" } else { [System.ConsoleColor]::White }
    'DarkGray' = if ($script:UseAnsiColors) { "`e[90m" } else { [System.ConsoleColor]::DarkGray }
    'Reset'    = if ($script:UseAnsiColors) { "`e[0m" } else { "" }
}

function Get-MSRDDiskAnalysis {
    <#
    .SYNOPSIS
    Analyzes storage and disk reliability using offline MSRD-Collect artifacts.

    .DESCRIPTION
    Scans System and SMB Client Connectivity event logs for disk/NTFS/Storport and Azure Files issues and
    parses SystemInfo text to estimate system drive free space. Adds findings and actionable recommendations.
    #>
    try {
        Write-ColorOutput -Message "Analyzing storage and disk health..." -Color Cyan

        if (-not $script:EventLogsPath -and -not $script:SystemInfoPath) {
            Write-ColorOutput -Message "Warning: EventLogs/SystemInfo directories not found; skipping disk analysis" -Color Yellow
            return
        }

        $startTimeUtc = (Get-Date -AsUTC).AddDays(-1 * $script:DaysToAnalyze)

        # Locate event logs
        $systemEvtx = $null
        $smbConnEvtx = $null

        if ($script:EventLogsPath -and (Test-Path -Path $script:EventLogsPath)) {
            $systemEvtx = Get-ChildItem -Path $script:EventLogsPath -Recurse -File -ErrorAction SilentlyContinue |
                Where-Object { $_.Name -match '^System.*\.evtx$' } |
                Select-Object -First 1

            $smbConnEvtx = Get-ChildItem -Path $script:EventLogsPath -Recurse -File -ErrorAction SilentlyContinue |
                Where-Object { $_.Name -match 'SMBClient.*Connectivity.*\.evtx$' -or $_.Name -match 'Microsoft-Windows-SMBClient%4Connectivity\.evtx$' } |
                Select-Object -First 1
        }

        # Disk-related events
        $diskEventIds = 7, 11, 15, 51, 55, 57, 98, 129, 130, 134, 135, 153, 157
        $diskEvents = @()

        if ($systemEvtx) {
            $diskEvents = Get-WinEvent -Path $systemEvtx.FullName -ErrorAction SilentlyContinue |
                Where-Object { ($_.Id -in $diskEventIds) -and ($_.TimeCreated -ge $startTimeUtc) } |
                Select-Object -Property TimeCreated, Id, ProviderName, LevelDisplayName, Message
        }

        if ($diskEvents.Count -gt 0) {
            # Capture detailed disk event entries
            foreach ($evt in $diskEvents) {
                $msg = $evt.Message
                $device = $null
                $volume = $null
                $deviceMatch = [regex]::Match($msg, "\\\\Device\\\\Harddisk\d+\\\\DR\d+")
                if ($deviceMatch.Success) { $device = $deviceMatch.Value }
                $volMatch = [regex]::Match($msg, "Volume\s+([A-Z]:)")
                if ($volMatch.Success) { $volume = $volMatch.Groups[1].Value }
                if (-not $volume) {
                    $volMatch2 = [regex]::Match($msg, "\b([A-Z]):\\")
                    if ($volMatch2.Success) { $volume = $volMatch2.Groups[1].Value + ':' }
                }

                $script:DiskEventDetails += [PSCustomObject]@{
                    TimeCreatedUtc = if ($evt.TimeCreated) { ($evt.TimeCreated.ToUniversalTime()).ToString('yyyy-MM-dd HH:mm:ss') } else { '' }
                    LogName        = 'System'
                    Id             = $evt.Id
                    Provider       = $evt.ProviderName
                    Level          = $evt.LevelDisplayName
                    Device         = $device
                    Volume         = $volume
                    ServerName     = ''
                    ShareName      = ''
                    Path           = ''
                    Status         = ''
                    Message        = ($msg -replace '\s+', ' ').Trim()
                    SourceFile     = $(if ($systemEvtx) { $systemEvtx.Name } else { 'System.evtx' })
                }
            }

            $grouped = $diskEvents | Group-Object -Property Id | Sort-Object -Property Count -Descending
            foreach ($g in $grouped) {
                $msg = "[Disk] Event ID $($g.Name) occurred $($g.Count) time(s) in the last $($script:DaysToAnalyze) day(s)."
                $script:DiskFindings += $msg

                $findingObj = [PSCustomObject]@{
                    Category = "Disk"
                    Type     = "Event ID"
                    Finding  = $msg
                    Severity = "Warning"
                    Source   = $(if ($systemEvtx) { $systemEvtx.Name } else { "System.evtx" })
                }

                switch ([int]$g.Name) {
                    { $_ -in 55, 7, 11, 15, 157 } { $findingObj.Severity = "Critical"; $script:CriticalIssues += $findingObj; continue }
                    default { $script:Warnings += $findingObj }
                }
            }

            # Tailored recommendations
            if ($grouped.Name -contains 55) {
                $script:Recommendations += [PSCustomObject]@{
                    Issue          = "NTFS corruption detected (Event ID 55)"
                    Recommendation = "Schedule offline chkdsk at next maintenance and review unexpected shutdowns"
                    Priority       = "High"
                    Category       = "Storage"
                    PowerShellCmd  = "chkdsk C: /F"
                }
            }
            if ($grouped.Name -contains 153) {
                $script:Recommendations += [PSCustomObject]@{
                    Issue          = "Storage retries detected (Event ID 153)"
                    Recommendation = "Investigate storage performance, drivers/firmware, and VM disk throughput/IOPS limits"
                    Priority       = "Medium"
                    Category       = "Storage"
                    PowerShellCmd  = "# Review Azure VM disk metrics and guest storage drivers"
                }
            }
            if ($grouped.Name -contains 129) {
                $script:Recommendations += [PSCustomObject]@{
                    Issue          = "Storport reset detected (Event ID 129)"
                    Recommendation = "Verify storage path stability and drivers; review host/storage incidents"
                    Priority       = "Medium"
                    Category       = "Storage"
                    PowerShellCmd  = "# Check storage multipath/driver health"
                }
            }
        }

        # SMB Client Connectivity for Azure Files
        if ($smbConnEvtx) {
            $smbIds = 30805, 30806, 30807, 30810, 31017
            $smbEvents = Get-WinEvent -Path $smbConnEvtx.FullName -ErrorAction SilentlyContinue |
                Where-Object { ($_.Id -in $smbIds) -and ($_.TimeCreated -ge $startTimeUtc) } |
                Select-Object -Property TimeCreated, Id, ProviderName, LevelDisplayName, Message

            if ($smbEvents.Count -gt 0) {
                # Extract detailed fields from Event XML where available
                foreach ($evt in $smbEvents) {
                    try {
                        [xml]$xml = $evt.ToXml()
                        $dataNodes = $xml.Event.EventData.Data
                        $dataMap = @{}
                        foreach ($n in $dataNodes) {
                            try {
                                $attr = $n.Attributes | Where-Object -Property Name -EQ -Value 'Name'
                                $key = if ($attr) { $attr.Value } else { '' }
                                $val = $n.'#text'
                                if ($key -and $val) { $dataMap[$key] = $val }
                            } catch {
                                Write-ColorOutput -Message "Warning: Failed to parse SMB event data node: $($_.Exception.Message)" -Color Yellow
                            }
                        }

                        # Fallback extraction from message using UNC regex
                        $server = $null
                        $share  = $null
                        $path   = $null
                        if ($dataMap.ContainsKey('ServerName')) { $server = $dataMap['ServerName'] }
                        if ($dataMap.ContainsKey('ShareName')) { $share  = $dataMap['ShareName'] }
                        if ($dataMap.ContainsKey('RemotePath')) { $path   = $dataMap['RemotePath'] }
                        if (-not $path -and $dataMap.ContainsKey('Path')) { $path = $dataMap['Path'] }

                        if (-not $server -or -not $share -or -not $path) {
                            $m = [regex]::Match($evt.Message, "\\\\\\\\([^\\]+)\\\\([^\\\s]+)([^\r\n\s]*)")
                            if ($m.Success) {
                                if (-not $server) { $server = $m.Groups[1].Value }
                                if (-not $share) { $share  = $m.Groups[2].Value }
                                if (-not $path) { $path   = "\\\\$($m.Groups[1].Value)\\$($m.Groups[2].Value)$($m.Groups[3].Value)" }
                            }
                        }

                        $status = ''
                        if ($dataMap.ContainsKey('Status')) { $status = $dataMap['Status'] }
                        if (-not $status) {
                            $statusMatch = [regex]::Match($evt.Message, 'Status[:=]\s*([^\s\.;]+)')
                            if ($statusMatch.Success) { $status = $statusMatch.Groups[1].Value }
                        }

                        $script:DiskEventDetails += [PSCustomObject]@{
                            TimeCreatedUtc = if ($evt.TimeCreated) { ($evt.TimeCreated.ToUniversalTime()).ToString('yyyy-MM-dd HH:mm:ss') } else { '' }
                            LogName        = 'SMB Connectivity'
                            Id             = $evt.Id
                            Provider       = $evt.ProviderName
                            Level          = $evt.LevelDisplayName
                            Device         = ''
                            Volume         = ''
                            ServerName     = $server
                            ShareName      = $share
                            Path           = $path
                            Status         = $status
                            Message        = ($evt.Message -replace '\s+', ' ').Trim()
                            SourceFile     = $smbConnEvtx.Name
                        }
                    } catch {
                        Write-ColorOutput -Message "Warning: Failed to parse SMB event XML: $($_.Exception.Message)" -Color Yellow
                    }
                }

                $gSmb = $smbEvents | Group-Object -Property Id | Sort-Object -Property Count -Descending
                foreach ($g in $gSmb) {
                    $msg = "[SMB] Connectivity Event ID $($g.Name) occurred $($g.Count) time(s) in the last $($script:DaysToAnalyze) day(s)."
                    $script:DiskFindings += $msg
                    $script:CriticalIssues += [PSCustomObject]@{
                        Category = "SMB Connectivity"
                        Type     = "Event ID"
                        Finding  = $msg
                        Severity = "Critical"
                        Source   = $smbConnEvtx.Name
                    }
                }

                $script:Recommendations += @(
                    [PSCustomObject]@{
                        Issue          = "Azure Files connectivity instability detected"
                        Recommendation = "Validate Kerberos for Azure Files, DNS for storage endpoint, clock skew, and NSG/Firewall"
                        Priority       = "High"
                        Category       = "FSLogix/Azure Files"
                        PowerShellCmd  = "# Validate SPNs, time sync, and port 445 connectivity to <storage-account>.file.core.windows.net"
                    },
                    [PSCustomObject]@{
                        Issue          = "Azure Files permissions/auth path validation"
                        Recommendation = "Confirm share and NTFS permissions and that auth path matches FSLogix configuration"
                        Priority       = "High"
                        Category       = "FSLogix/Azure Files"
                        PowerShellCmd  = "# Review effective permissions for target users/computers"
                    }
                )
            }
        }

        # System drive free space from text exports
        if ($script:SystemInfoPath -and (Test-Path -Path $script:SystemInfoPath)) {
            $infoFiles = Get-ChildItem -Path $script:SystemInfoPath -Recurse -File -ErrorAction SilentlyContinue |
                Where-Object { $_.Extension -in '.txt', '.log', '.csv' }

            $sysText = @()
            foreach ($f in $infoFiles) {
                try {
                    $sysText += Get-Content -Path $f.FullName -ErrorAction SilentlyContinue -TotalCount 2000
                } catch {
                    Write-ColorOutput -Message "Warning: Could not read system info file $($f.Name): $($_.Exception.Message)" -Color Yellow
                }
            }

            if ($sysText.Count -gt 0) {
                $cLines = $sysText | Where-Object { $_ -match '^\s*C:\\\s' -or $_ -match '^\s*Drive\s*C:' -or $_ -match '^\s*Volume\s+C:' }
                if (-not $cLines) {
                    $cLines = $sysText | Where-Object { ($_ -match 'C:\\\\') -and ($_ -match 'Free') }
                }

                $freePercent = $null
                $freeGB = $null

                foreach ($line in $cLines) {
                    if (-not $freePercent) {
                        $m = [regex]::Match($line, '(?<pct>\d{1,3})\s*%')
                        if ($m.Success) { $freePercent = [int]$m.Groups['pct'].Value }
                    }
                    if (-not $freeGB) {
                        $m2 = [regex]::Match($line, '(?<gb>\d+(?:\.\d+)?)\s*GB', 'IgnoreCase')
                        if ($m2.Success) { $freeGB = [double]$m2.Groups['gb'].Value }
                    }
                }

                if ($freePercent -and ($freePercent -lt $script:MinSystemDriveFreePercent)) {
                    $msg = "System drive free space is low: ${freePercent}% (< ${script:MinSystemDriveFreePercent}%)."
                    $script:DiskFindings += $msg
                    $script:CriticalIssues += [PSCustomObject]@{
                        Category = "Disk Space"
                        Type     = "Free Space"
                        Finding  = $msg
                        Severity = "Critical"
                        Source   = "SystemInfo"
                    }
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = "Low system drive free space"
                        Recommendation = "Free space on C: to at least ${script:MinSystemDriveFreePercent}% to reduce FSLogix/AVD reliability issues"
                        Priority       = "High"
                        Category       = "Storage"
                        PowerShellCmd  = "# Clean temp files; expand OS disk if needed"
                    }
                }

                if ($freeGB -and ($freeGB -lt $script:MinTempFreeGB)) {
                    $msg = "System drive free space in GB is low: ${freeGB} GB (< ${script:MinTempFreeGB} GB)."
                    $script:DiskFindings += $msg
                    $script:Warnings += [PSCustomObject]@{
                        Category = "Disk Space"
                        Type     = "Free Space"
                        Finding  = $msg
                        Severity = "Warning"
                        Source   = "SystemInfo"
                    }
                }
            }
        }

        # FSLogix linkage reminders
        if ($script:FSLogixFindings.Count -gt 0) {
            $script:Recommendations += [PSCustomObject]@{
                Issue          = "FSLogix Event ID 26 and storage reliability"
                Recommendation = "Review 'DisablePersonalDirChange' policy and ensure storage identity (Kerberos) aligns with FSLogix settings"
                Priority       = "Medium"
                Category       = "FSLogix"
                PowerShellCmd  = "# Validate GPO and FSLogix configuration"
            }
        }

        Write-ColorOutput -Message "Storage and disk health analysis completed" -Color Green

    } catch {
        Write-ColorOutput -Message "[SCRIPT ERROR] Get-MSRDDiskAnalysis failed: $($_.Exception.Message)" -Color Red
    }
}

function Write-ColorOutput {
    <#
    .SYNOPSIS
    Writes colored output to the console with cross-version compatibility.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Message,
        [Parameter(Mandatory = $false)]
        [string]$Color = "White"
    )

    if ($script:UseAnsiColors) {
        # PowerShell 7+ with ANSI escape codes
        $colorCode = $script:Colors[$Color]
        $resetCode = $script:Colors.Reset
        Write-Output "${colorCode}${Message}${resetCode}"
    } else {
        # PowerShell 5.1 - Change console color, write output, then reset
        $originalColor = $Host.UI.RawUI.ForegroundColor
        try {
            if ($script:Colors[$Color] -and $script:Colors[$Color] -ne "") {
                $Host.UI.RawUI.ForegroundColor = $script:Colors[$Color]
            }
            Write-Output $Message
        } finally {
            $Host.UI.RawUI.ForegroundColor = $originalColor
        }
    }
}

function Initialize-AnalysisEnvironment {
    <#
    .SYNOPSIS
    Initializes the analysis environment and validates prerequisites.
    #>
    try {
        Write-ColorOutput -Message "Initializing MSRD-Collect output analysis environment..." -Color Cyan

        # Extract computer name from directory structure
        $allFolders = Get-ChildItem -Path $script:MSRDOutputPath -Directory -ErrorAction SilentlyContinue
        if ($allFolders.Count -gt 0) {
            # Extract computer name from first folder (assumes naming convention: COMPUTERNAME_FolderType)
            $sampleFolder = $allFolders[0].Name
            $script:ComputerName = ($sampleFolder -split "_")[0]
            Write-ColorOutput -Message "Detected computer name: $script:ComputerName" -Color Green
        }

        # Validate MSRD output directory structure and populate global paths
        Write-ColorOutput -Message "Scanning MSRD-Collect output directory structure..." -Color Cyan

        # Find all expected directories with computer name prefixes
        $script:EventLogsPath = ($allFolders | Where-Object { $_.Name -like "*EventLogs" } | Select-Object -First 1)?.FullName
        $script:RegistryPath = ($allFolders | Where-Object { $_.Name -like "*RegistryKeys" } | Select-Object -First 1)?.FullName
        $script:SystemInfoPath = ($allFolders | Where-Object { $_.Name -like "*SystemInfo" } | Select-Object -First 1)?.FullName
        $script:NetworkingPath = ($allFolders | Where-Object { $_.Name -like "*Networking" } | Select-Object -First 1)?.FullName
        $script:AVDPath = ($allFolders | Where-Object { $_.Name -like "*AVD" } | Select-Object -First 1)?.FullName
        $script:ProfilesPath = ($allFolders | Where-Object { $_.Name -like "*Profiles" } | Select-Object -First 1)?.FullName
        $script:CertificatesPath = ($allFolders | Where-Object { $_.Name -like "*Certificates" } | Select-Object -First 1)?.FullName
        $script:MDMPath = ($allFolders | Where-Object { $_.Name -like "*MDM" } | Select-Object -First 1)?.FullName
        $script:IMEPath = ($allFolders | Where-Object { $_.Name -like "*IME" } | Select-Object -First 1)?.FullName

        Write-ColorOutput -Message "Found directory structure:" -Color DarkGray
        Write-ColorOutput -Message "  EventLogs: $(if ($script:EventLogsPath) { 'Found' } else { 'Missing' })" -Color $(if ($script:EventLogsPath) { 'Green' } else { 'Yellow' })
        Write-ColorOutput -Message "  Registry: $(if ($script:RegistryPath) { 'Found' } else { 'Missing' })" -Color $(if ($script:RegistryPath) { 'Green' } else { 'Yellow' })
        Write-ColorOutput -Message "  SystemInfo: $(if ($script:SystemInfoPath) { 'Found' } else { 'Missing' })" -Color $(if ($script:SystemInfoPath) { 'Green' } else { 'Yellow' })
        Write-ColorOutput -Message "  Networking: $(if ($script:NetworkingPath) { 'Found' } else { 'Missing' })" -Color $(if ($script:NetworkingPath) { 'Green' } else { 'Yellow' })
        Write-ColorOutput -Message "  AVD: $(if ($script:AVDPath) { 'Found' } else { 'Missing' })" -Color $(if ($script:AVDPath) { 'Green' } else { 'Yellow' })
        Write-ColorOutput -Message "  Profiles: $(if ($script:ProfilesPath) { 'Found' } else { 'Missing' })" -Color $(if ($script:ProfilesPath) { 'Green' } else { 'Yellow' })
        Write-ColorOutput -Message "  Certificates: $(if ($script:CertificatesPath) { 'Found' } else { 'Missing' })" -Color $(if ($script:CertificatesPath) { 'Green' } else { 'Yellow' })
        Write-ColorOutput -Message "  MDM: $(if ($script:MDMPath) { 'Found' } else { 'Missing' })" -Color $(if ($script:MDMPath) { 'Green' } else { 'Yellow' })
        Write-ColorOutput -Message "  IME: $(if ($script:IMEPath) { 'Found' } else { 'Missing' })" -Color $(if ($script:IMEPath) { 'Green' } else { 'Yellow' })

        # Check for MSRD diagnostic files
        $diagnosticFiles = Get-ChildItem -Path $script:MSRDOutputPath -Filter "*MSRD-Diag*.txt" -ErrorAction SilentlyContinue
        $htmlReports = Get-ChildItem -Path $script:MSRDOutputPath -Filter "*MSRD-Diag*.html" -ErrorAction SilentlyContinue

        Write-ColorOutput -Message "Found $($diagnosticFiles.Count) diagnostic text files" -Color DarkGray
        Write-ColorOutput -Message "Found $($htmlReports.Count) HTML diagnostic reports" -Color DarkGray

        # Create report directory if it doesn't exist
        if (-not (Test-Path -Path $script:ReportPath)) {
            New-Item -Path $script:ReportPath -ItemType Directory -Force | Out-Null
            Write-ColorOutput -Message "Created report directory: $script:ReportPath" -Color Green
        }

        # Initialize transcript logging
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        $logFileName = "MSRD-Analysis-$env:COMPUTERNAME-$timestamp.log"
        $logPath = Join-Path -Path $script:ReportPath -ChildPath $logFileName
        Start-Transcript -Path $logPath -Force

        Write-ColorOutput -Message "Analysis environment initialized successfully" -Color Green
        Write-ColorOutput -Message "Log file: $logPath" -Color DarkGray

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Failed to initialize analysis environment: $($_.Exception.Message)" -Color Red
        throw
    }
}

function Get-MSRDSystemInfo {
    <#
    .SYNOPSIS
    Analyzes comprehensive system information from MSRD-Collect output.
    #>
    try {
        Write-ColorOutput -Message "Analyzing system information..." -Color Cyan

        if (-not $script:SystemInfoPath) {
            Write-ColorOutput -Message "Warning: SystemInfo directory not found" -Color Yellow
            return
        }

        Write-Verbose "Using SystemInfo path: $script:SystemInfoPath"

        # Look for system info files
        $systemFiles = Get-ChildItem -Path $script:SystemInfoPath -Filter "*.txt" -ErrorAction SilentlyContinue

        foreach ($file in $systemFiles) {
            Write-Verbose "Processing system info file: $($file.Name)"
            $content = Get-Content -Path $file.FullName -ErrorAction SilentlyContinue

            # Analyze system specifications
            if ($file.Name -like "*systeminfo*") {
                $osVersion = $content | Where-Object { $_ -like "*OS Name*" }
                $totalMemory = $content | Where-Object { $_ -like "*Total Physical Memory*" }
                $availableMemory = $content | Where-Object { $_ -like "*Available Physical Memory*" }
                $uptime = $content | Where-Object { $_ -like "*System Boot Time*" }

                if ($osVersion) {
                    $osName = $osVersion.Split(':')[1].Trim()
                    Write-ColorOutput -Message "Operating System: $osName" -Color White

                    # Check for unsupported OS versions
                    if ($osName -like "*Windows 7*" -or $osName -like "*Windows 8*" -or $osName -like "*Server 2008*") {
                        $script:CriticalIssues += [PSCustomObject]@{
                            Category = "System Info"
                            Type     = "OS Version"
                            Finding  = "Unsupported operating system detected: $osName"
                            Severity = "Critical"
                            Source   = $file.Name
                        }
                    }
                }

                if ($totalMemory -and $availableMemory) {
                    $totalMB = [regex]::Match($totalMemory, '[\d,]+').Value -replace ',', ''
                    $availableMB = [regex]::Match($availableMemory, '[\d,]+').Value -replace ',', ''

                    if ($totalMB -and $availableMB) {
                        $totalGB = [math]::Round([int]$totalMB / 1024, 2)
                        $availableGB = [math]::Round([int]$availableMB / 1024, 2)
                        $usedPercent = [math]::Round((($totalGB - $availableGB) / $totalGB) * 100, 1)

                        Write-ColorOutput -Message "Memory: $totalGB GB total, $availableGB GB available ($usedPercent% used)" -Color White

                        # Memory analysis
                        if ($usedPercent -gt 90) {
                            $script:CriticalIssues += [PSCustomObject]@{
                                Category = "System Info"
                                Type     = "Memory"
                                Finding  = "Critical memory usage: $usedPercent% ($availableGB GB available of $totalGB GB)"
                                Severity = "Critical"
                                Source   = $file.Name
                            }
                        } elseif ($usedPercent -gt 80) {
                            $script:Warnings += [PSCustomObject]@{
                                Category = "System Info"
                                Type     = "Memory"
                                Finding  = "High memory usage: $usedPercent% ($availableGB GB available of $totalGB GB)"
                                Severity = "Warning"
                                Source   = $file.Name
                            }
                        }

                        if ($totalGB -lt 4) {
                            $script:Warnings += [PSCustomObject]@{
                                Category = "System Info"
                                Type     = "Memory"
                                Finding  = "Low total memory for RDS/AVD: $totalGB GB (minimum 8GB recommended)"
                                Severity = "Warning"
                                Source   = $file.Name
                            }
                        }
                    }
                }

                if ($uptime) {
                    $bootTime = $uptime.Split(':', 2)[1].Trim()
                    $script:DetailedFindings += [PSCustomObject]@{
                        Category = "System Info"
                        Type     = "Uptime"
                        Finding  = "System boot time: $bootTime"
                        Severity = "Info"
                        Source   = $file.Name
                    }
                }
            }

            # Analyze installed software and potential conflicts
            if ($file.Name -like "*Software*" -or $file.Name -like "*Programs*") {
                $knownConflicts = @(
                    "TeamViewer", "VNC", "Remote Utilities", "AnyDesk", "LogMeIn",
                    "Chrome Remote Desktop", "Splashtop", "GoToMyPC"
                )

                foreach ($conflict in $knownConflicts) {
                    $found = $content | Where-Object { $_ -like "*$conflict*" }
                    if ($found) {
                        $script:Warnings += [PSCustomObject]@{
                            Category = "System Info"
                            Type     = "Software Conflict"
                            Finding  = "Potential RDP conflict detected: $conflict software installed"
                            Severity = "Warning"
                            Source   = $file.Name
                        }
                    }
                }
            }

            # Analyze services
            if ($file.Name -like "*Services*") {
                $criticalServices = @(
                    "TermService", "UmRdpService", "SessionEnv", "RdpCoreService",
                    "Winmgmt", "BITS", "EventLog", "PlugPlay", "ProfSvc", "Themes",
                    "AudioSrv", "AudioEndpointBuilder"
                )

                foreach ($service in $criticalServices) {
                    $serviceInfo = $content | Where-Object { $_ -like "*$service*" }
                    if ($serviceInfo) {
                        $stopped = $serviceInfo | Where-Object { $_ -like "*Stopped*" }
                        if ($stopped) {
                            $script:CriticalIssues += [PSCustomObject]@{
                                Category = "System Info"
                                Type     = "Service Status"
                                Finding  = "Critical RDS service is stopped: $service"
                                Severity = "Critical"
                                Source   = $file.Name
                            }
                        }
                    }
                }
            }

            # Analyze drivers
            if ($file.Name -like "*Drivers*") {
                $displayDrivers = $content | Where-Object { $_ -like "*display*" -or $_ -like "*video*" -or $_ -like "*graphics*" }
                if ($displayDrivers) {
                    $script:DetailedFindings += [PSCustomObject]@{
                        Category = "System Info"
                        Type     = "Drivers"
                        Finding  = "Display drivers found: $($displayDrivers.Count) entries"
                        Severity = "Info"
                        Source   = $file.Name
                    }
                }
            }
        }

        Write-ColorOutput -Message "System information analysis completed" -Color Green

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error analyzing system information: $($_.Exception.Message)" -Color Red
    }
}

function Get-MSRDEventLog {
    <#
    .SYNOPSIS
    Analyzes event logs from MSRD-Collect output for RDS-related issues.
    #>
    try {
        Write-ColorOutput -Message "Analyzing event logs for Remote Desktop issues..." -Color Cyan

        # Find EventLogs directory with computer name prefix
        $allFolders = Get-ChildItem -Path $script:MSRDOutputPath -Directory -ErrorAction SilentlyContinue
        $eventLogsFolder = $allFolders | Where-Object { $_.Name -like "*EventLogs" } | Select-Object -First 1

        if (-not $eventLogsFolder) {
            Write-ColorOutput -Message "Warning: EventLogs directory not found" -Color Yellow
            return
        }

        $eventLogsPath = $eventLogsFolder.FullName
        Write-Verbose "Using EventLogs path: $eventLogsPath"

        $eventLogFiles = Get-ChildItem -Path $eventLogsPath -Filter "*.evtx" -ErrorAction SilentlyContinue

        Write-ColorOutput -Message "Found $($eventLogFiles.Count) event log files to analyze" -Color DarkGray

        # For MSRD-Collect, we'll analyze specific RDS-related logs
        $rdsLogFiles = $eventLogFiles | Where-Object {
            $_.Name -like "*TerminalServices*" -or
            $_.Name -like "*RemoteDesktop*" -or
            $_.Name -like "*System*" -or
            $_.Name -like "*Application*" -or
            $_.Name -like "*Security*"
        }

        if ($rdsLogFiles.Count -gt 0) {
            Write-ColorOutput -Message "Analyzing $($rdsLogFiles.Count) RDS-related event logs..." -Color DarkGray

            foreach ($eventFile in $rdsLogFiles) {
                Write-Verbose "Found RDS-related log: $($eventFile.Name)"

                $script:DetailedFindings += [PSCustomObject]@{
                    Category = "Event Logs"
                    Type     = "Log File"
                    Finding  = "Found RDS-related event log: $($eventFile.Name)"
                    Severity = "Info"
                    Source   = $eventFile.Name
                }
            }
        }

        Write-ColorOutput -Message "Event log analysis completed" -Color Green

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error analyzing event logs: $($_.Exception.Message)" -Color Red
    }
}

function Get-MSRDRegistryAnalysis {
    <#
    .SYNOPSIS
    Analyzes registry exports for RDS configuration issues.
    #>
    try {
        Write-ColorOutput -Message "Analyzing registry configuration..." -Color Cyan

        # Find RegistryKeys directory with computer name prefix
        $allFolders = Get-ChildItem -Path $script:MSRDOutputPath -Directory -ErrorAction SilentlyContinue
        $registryFolder = $allFolders | Where-Object { $_.Name -like "*RegistryKeys" } | Select-Object -First 1

        if (-not $registryFolder) {
            Write-ColorOutput -Message "Warning: RegistryKeys directory not found" -Color Yellow
            return
        }

        $registryPath = $registryFolder.FullName
        Write-Verbose "Using Registry path: $registryPath"

        $registryFiles = Get-ChildItem -Path $registryPath -Filter "*.txt" -ErrorAction SilentlyContinue

        Write-ColorOutput -Message "Found $($registryFiles.Count) registry export files" -Color DarkGray

        # Look for Terminal Services related registry files
        $tsRegistryFiles = $registryFiles | Where-Object {
            $_.Name -like "*TerminalServices*" -or
            $_.Name -like "*Terminal*" -or
            $_.Name -like "*RDP*" -or
            $_.Name -like "*TS*"
        }

        foreach ($regFile in $tsRegistryFiles) {
            Write-Verbose "Processing Terminal Services registry file: $($regFile.Name)"

            try {
                $regContent = Get-Content -Path $regFile.FullName -ErrorAction SilentlyContinue

                if ($regContent) {
                    # Look for common configuration issues
                    $tsDisabled = $regContent | Where-Object { $_ -like "*fDenyTSConnections*" -and $_ -like "*0x1*" }
                    $nlaDisabled = $regContent | Where-Object { $_ -like "*UserAuthentication*" -and $_ -like "*0x0*" }

                    if ($tsDisabled) {
                        $script:CriticalIssues += [PSCustomObject]@{
                            Category = "Registry"
                            Type     = "Configuration"
                            Finding  = "Terminal Services connections are disabled (fDenyTSConnections=1)"
                            Severity = "Critical"
                            Source   = $regFile.Name
                        }
                    }

                    if ($nlaDisabled) {
                        $script:Warnings += [PSCustomObject]@{
                            Category = "Registry"
                            Type     = "Security"
                            Finding  = "Network Level Authentication is disabled"
                            Severity = "Warning"
                            Source   = $regFile.Name
                        }
                    }

                    $script:DetailedFindings += [PSCustomObject]@{
                        Category = "Registry"
                        Type     = "Analysis"
                        Finding  = "Analyzed Terminal Services registry file: $($regFile.Name)"
                        Severity = "Info"
                        Source   = $regFile.Name
                    }
                }

            } catch {
                Write-ColorOutput -Message "Warning: Could not process registry file $($regFile.Name): $($_.Exception.Message)" -Color Yellow
            }
        }

        Write-ColorOutput -Message "Registry analysis completed" -Color Green

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error analyzing registry: $($_.Exception.Message)" -Color Red
    }
}

function Get-MSRDNetworkAnalysis {
    <#
    .SYNOPSIS
    Analyzes network configuration for RDS connectivity issues.
    #>
    try {
        Write-ColorOutput -Message "Analyzing network configuration..." -Color Cyan

        # Find Networking directory with computer name prefix
        $allFolders = Get-ChildItem -Path $script:MSRDOutputPath -Directory -ErrorAction SilentlyContinue
        $networkingFolder = $allFolders | Where-Object { $_.Name -like "*Networking" } | Select-Object -First 1

        if (-not $networkingFolder) {
            Write-ColorOutput -Message "Warning: Networking directory not found" -Color Yellow
            return
        }

        $networkingPath = $networkingFolder.FullName
        Write-Verbose "Using Networking path: $networkingPath"

        $networkFiles = Get-ChildItem -Path $networkingPath -Filter "*.txt" -ErrorAction SilentlyContinue

        Write-ColorOutput -Message "Found $($networkFiles.Count) network configuration files" -Color DarkGray

        foreach ($netFile in $networkFiles) {
            Write-Verbose "Processing network file: $($netFile.Name)"

            try {
                $netContent = Get-Content -Path $netFile.FullName -ErrorAction SilentlyContinue

                # Analyze for RDP port configuration
                if ($netFile.Name -like "*netstat*") {
                    $rdpPorts = $netContent | Where-Object { $_ -like "*:3389*" }

                    if (-not $rdpPorts) {
                        $script:CriticalIssues += [PSCustomObject]@{
                            Category = "Network"
                            Type     = "Port Configuration"
                            Finding  = "RDP port 3389 is not listening"
                            Severity = "Critical"
                            Source   = $netFile.Name
                        }
                    } else {
                        $script:DetailedFindings += [PSCustomObject]@{
                            Category = "Network"
                            Type     = "Port Status"
                            Finding  = "RDP port 3389 is active and listening"
                            Severity = "Info"
                            Source   = $netFile.Name
                        }
                    }
                }

                # Analyze firewall rules
                if ($netFile.Name -like "*firewall*" -or $netFile.Name -like "*netsh*") {
                    $rdpRules = $netContent | Where-Object { $_ -like "*Remote Desktop*" -or $_ -like "*3389*" }

                    if ($rdpRules) {
                        $enabledRules = $rdpRules | Where-Object { $_ -like "*Enabled*" -or $_ -like "*Yes*" }

                        if (-not $enabledRules) {
                            $script:CriticalIssues += [PSCustomObject]@{
                                Category = "Network"
                                Type     = "Firewall"
                                Finding  = "Remote Desktop firewall rules are disabled"
                                Severity = "Critical"
                                Source   = $netFile.Name
                            }
                        }
                    }
                }

                $script:DetailedFindings += [PSCustomObject]@{
                    Category = "Network"
                    Type     = "Analysis"
                    Finding  = "Analyzed network configuration file: $($netFile.Name)"
                    Severity = "Info"
                    Source   = $netFile.Name
                }

            } catch {
                Write-ColorOutput -Message "Warning: Could not process network file $($netFile.Name): $($_.Exception.Message)" -Color Yellow
            }
        }

        Write-ColorOutput -Message "Network analysis completed" -Color Green

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error analyzing network configuration: $($_.Exception.Message)" -Color Red
    }
}

function Get-MSRDAVDAnalysis {
    <#
    .SYNOPSIS
    Analyzes Azure Virtual Desktop specific diagnostics and configuration.
    #>
    try {
        if (-not $script:IncludeAVDAnalysis) {
            Write-Verbose "AVD analysis disabled"
            return
        }

        Write-ColorOutput -Message "Analyzing Azure Virtual Desktop configuration..." -Color Cyan

        if (-not $script:AVDPath) {
            Write-ColorOutput -Message "Warning: AVD directory not found" -Color Yellow
            return
        }

        Write-Verbose "Using AVD path: $script:AVDPath"

        # Analyze AVD-specific files
        $avdFiles = Get-ChildItem -Path $script:AVDPath -Filter "*.txt" -ErrorAction SilentlyContinue

        foreach ($file in $avdFiles) {
            Write-Verbose "Processing AVD file: $($file.Name)"
            $content = Get-Content -Path $file.FullName -ErrorAction SilentlyContinue

            # Analyze agent installation status
            if ($file.Name -like "*AgentInstall*") {
                # Look for actual errors, not successful installations
                $realErrors = $content | Where-Object {
                    ($_ -like "*error*" -and $_ -notlike "*error status: 0*") -or
                    ($_ -like "*failed*") -or
                    ($_ -like "*error status: 1*") -or
                    ($_ -like "*error status: 2*") -or
                    ($_ -like "*error status: 3*")
                }

                if ($realErrors) {
                    foreach ($errorLine in $realErrors) {
                        $script:CriticalIssues += [PSCustomObject]@{
                            Category = "AVD"
                            Type     = "Agent Installation"
                            Finding  = "AVD Agent installation error: $errorLine"
                            Severity = "Critical"
                            Source   = $file.Name
                        }
                    }
                }

                # Look for successful installations
                $successfulInstalls = $content | Where-Object { $_ -like "*error status: 0*" }
                if ($successfulInstalls) {
                    $script:AVDFindings += [PSCustomObject]@{
                        Category = "AVD"
                        Type     = "Agent Status"
                        Finding  = "AVD Agent installations completed successfully ($($successfulInstalls.Count) installations found)"
                        Severity = "Info"
                        Source   = $file.Name
                    }
                }
            }

            # Analyze network connectivity test results
            if ($file.Name -like "*avdnettest*" -or $file.Name -like "*AVDServicesURIHealth*") {
                $failedTests = $content | Where-Object { $_ -like "*failed*" -or $_ -like "*unreachable*" -or $_ -like "*timeout*" }
                if ($failedTests) {
                    foreach ($failure in $failedTests) {
                        $script:CriticalIssues += [PSCustomObject]@{
                            Category = "AVD"
                            Type     = "Network Connectivity"
                            Finding  = "AVD network connectivity failure: $failure"
                            Severity = "Critical"
                            Source   = $file.Name
                        }
                    }
                } else {
                    $script:AVDFindings += [PSCustomObject]@{
                        Category = "AVD"
                        Type     = "Network Status"
                        Finding  = "AVD network connectivity tests passed"
                        Severity = "Info"
                        Source   = $file.Name
                    }
                }
            }

            # Analyze session information
            if ($file.Name -like "*Qwinsta*") {
                $sessions = $content | Where-Object { $_ -match "^\s*\w+\s+\w+\s+\d+" }
                $activeSessions = $sessions | Where-Object { $_ -like "*Active*" }
                $disconnectedSessions = $sessions | Where-Object { $_ -like "*Disc*" }

                $script:AVDFindings += [PSCustomObject]@{
                    Category = "AVD"
                    Type     = "Session Status"
                    Finding  = "Active sessions: $($activeSessions.Count), Disconnected: $($disconnectedSessions.Count)"
                    Severity = "Info"
                    Source   = $file.Name
                }

                if ($disconnectedSessions.Count -gt 5) {
                    $script:Warnings += [PSCustomObject]@{
                        Category = "AVD"
                        Type     = "Session Management"
                        Finding  = "High number of disconnected sessions: $($disconnectedSessions.Count)"
                        Severity = "Warning"
                        Source   = $file.Name
                    }
                }
            }

            # Analyze listener permissions
            if ($file.Name -like "*ListenerPermissions*") {
                $permissionErrors = $content | Where-Object { $_ -like "*denied*" -or $_ -like "*failed*" }
                if ($permissionErrors) {
                    foreach ($errorLine in $permissionErrors) {
                        $script:CriticalIssues += [PSCustomObject]@{
                            Category = "AVD"
                            Type     = "Permissions"
                            Finding  = "RDP listener permission issue: $errorLine"
                            Severity = "Critical"
                            Source   = $file.Name
                        }
                    }
                }
            }

            # Analyze local group membership
            if ($file.Name -like "*LocalGroupsMembership*") {
                $rdpUsers = $content | Where-Object { $_ -like "*Remote Desktop Users*" }
                if (-not $rdpUsers) {
                    $script:Warnings += [PSCustomObject]@{
                        Category = "AVD"
                        Type     = "User Management"
                        Finding  = "No users found in Remote Desktop Users group"
                        Severity = "Warning"
                        Source   = $file.Name
                    }
                }
            }
        }

        # Check for monitoring directory
        $monitoringPath = Join-Path -Path $script:AVDPath -ChildPath "Monitoring"
        if (Test-Path -Path $monitoringPath) {
            $monitoringFiles = Get-ChildItem -Path $monitoringPath -ErrorAction SilentlyContinue
            $script:AVDFindings += [PSCustomObject]@{
                Category = "AVD"
                Type     = "Monitoring"
                Finding  = "Found $($monitoringFiles.Count) monitoring files"
                Severity = "Info"
                Source   = "Monitoring folder"
            }
        }

        Write-ColorOutput -Message "AVD analysis completed - Found $($script:AVDFindings.Count) findings" -Color Green

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error analyzing AVD configuration: $($_.Exception.Message)" -Color Red
    }
}

function Get-MSRDFSLogixAnalysis {
    <#
    .SYNOPSIS
    Analyzes FSLogix profile container configuration and issues.
    #>
    try {
        if (-not $script:IncludeFSLogixAnalysis) {
            Write-Verbose "FSLogix analysis disabled"
            return
        }

        Write-ColorOutput -Message "Analyzing FSLogix profile containers..." -Color Cyan

        if (-not $script:ProfilesPath) {
            Write-ColorOutput -Message "Warning: Profiles directory not found" -Color Yellow
            return
        }

        Write-Verbose "Using Profiles path: $script:ProfilesPath"

        # Check for FSLogix diagnostic file in main directory
        $fslogixDiagFile = Get-ChildItem -Path $script:MSRDOutputPath -Filter "*MSRD-Diag-FSLogix.txt" -ErrorAction SilentlyContinue
        if ($fslogixDiagFile) {
            Write-ColorOutput -Message "Analyzing FSLogix diagnostic report..." -Color DarkGray
            $fslogixContent = Get-Content -Path $fslogixDiagFile.FullName -ErrorAction SilentlyContinue

            # Parse FSLogix errors
            $errorEntries = @()
            $currentEntry = @{}

            foreach ($line in $fslogixContent) {
                if ($line -like "Time Created*") {
                    if ($currentEntry.Count -gt 0) {
                        $errorEntries += $currentEntry
                    }
                    $currentEntry = @{ TimeCreated = $line.Split(':', 2)[1].Trim() }
                } elseif ($line -like "Event Log*") {
                    $currentEntry.EventLog = $line.Split(':', 2)[1].Trim()
                } elseif ($line -like "Id*") {
                    $currentEntry.Id = $line.Split(':', 2)[1].Trim()
                } elseif ($line -like "Level*") {
                    $currentEntry.Level = $line.Split(':', 2)[1].Trim()
                } elseif ($line -like "Message*") {
                    $currentEntry.Message = $line.Split(':', 2)[1].Trim()
                } elseif ($line -eq "============================================================") {
                    if ($currentEntry.Count -gt 0) {
                        $errorEntries += $currentEntry
                        $currentEntry = @{}
                    }
                }
            }

            # Analyze FSLogix events by type
            $criticalEvents = @(1, 2, 3, 4, 13, 14, 26, 41, 42, 43, 44, 45)
            $warningEvents = @(10, 11, 25, 27, 28, 29, 30, 31, 32, 33, 34, 35)

            foreach ($entry in $errorEntries) {
                if ($entry.Id -and $entry.Message) {
                    $eventId = [int]$entry.Id

                    if ($criticalEvents -contains $eventId) {
                        $script:CriticalIssues += [PSCustomObject]@{
                            Category = "FSLogix"
                            Type     = "Profile Error"
                            Finding  = "Event ID $eventId`: $($entry.Message)"
                            Severity = "Critical"
                            Source   = "FSLogix Event Log"
                        }
                    } elseif ($warningEvents -contains $eventId) {
                        $script:Warnings += [PSCustomObject]@{
                            Category = "FSLogix"
                            Type     = "Profile Warning"
                            Finding  = "Event ID $eventId`: $($entry.Message)"
                            Severity = "Warning"
                            Source   = "FSLogix Event Log"
                        }
                    } else {
                        $script:FSLogixFindings += [PSCustomObject]@{
                            Category = "FSLogix"
                            Type     = "Profile Event"
                            Finding  = "Event ID $eventId`: $($entry.Message)"
                            Severity = "Info"
                            Source   = "FSLogix Event Log"
                        }
                    }
                }
            }

            # Look for specific FSLogix issues
            $knownIssues = @{
                "SHSetKnownFolderPath failed"      = "DisablePersonalDirChange group policy may be preventing FSLogix folder redirection"
                "VHD mounting failed"              = "Profile container VHD file corruption or network connectivity issue"
                "Profile directory not accessible" = "Network share permissions or connectivity problem"
                "Office activation failed"         = "FSLogix Office container activation issue"
                "Search index corruption"          = "Windows Search index corruption in profile container"
            }

            foreach ($issue in $knownIssues.Keys) {
                $matchedEntries = $errorEntries | Where-Object { $_.Message -like "*$issue*" }
                if ($matchedEntries) {
                    $script:CriticalIssues += [PSCustomObject]@{
                        Category = "FSLogix"
                        Type     = "Known Issue"
                        Finding  = "$issue - $($knownIssues[$issue])"
                        Severity = "Critical"
                        Source   = "FSLogix Analysis"
                    }
                }
            }
        }

        # Analyze FSLogix folder structure
        $fslogixFolder = Get-ChildItem -Path $script:ProfilesPath -Directory -Filter "*FSLogix*" -ErrorAction SilentlyContinue
        if ($fslogixFolder) {
            $fslogixFiles = Get-ChildItem -Path $fslogixFolder.FullName -Filter "*.txt" -ErrorAction SilentlyContinue
            foreach ($file in $fslogixFiles) {
                $content = Get-Content -Path $file.FullName -ErrorAction SilentlyContinue

                # Analyze folder permissions
                if ($file.Name -like "*folderPermissions*") {
                    $accessDenied = $content | Where-Object { $_ -like "*Access is denied*" -or $_ -like "*Error=0x5*" }
                    if ($accessDenied) {
                        $script:CriticalIssues += [PSCustomObject]@{
                            Category = "FSLogix"
                            Type     = "Permissions"
                            Finding  = "FSLogix profile share access denied - check network share permissions"
                            Severity = "Critical"
                            Source   = $file.Name
                        }
                    }
                }
            }
        }

        Write-ColorOutput -Message "FSLogix analysis completed - Found $($script:FSLogixFindings.Count) findings" -Color Green

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error analyzing FSLogix configuration: $($_.Exception.Message)" -Color Red
    }
}

function Get-MSRDCertificateAnalysis {
    <#
    .SYNOPSIS
    Analyzes certificate configuration and expiration status.
    #>
    try {
        Write-ColorOutput -Message "Analyzing certificate configuration..." -Color Cyan

        if (-not $script:CertificatesPath) {
            Write-ColorOutput -Message "Warning: Certificates directory not found" -Color Yellow
            return
        }

        Write-Verbose "Using Certificates path: $script:CertificatesPath"

        $certFiles = Get-ChildItem -Path $script:CertificatesPath -Filter "*.txt" -ErrorAction SilentlyContinue

        foreach ($file in $certFiles) {
            Write-Verbose "Processing certificate file: $($file.Name)"
            $content = Get-Content -Path $file.FullName -ErrorAction SilentlyContinue

            # Analyze certificate expiration
            $expiringCerts = $content | Where-Object { $_ -like "*expires*" -or $_ -like "*valid*" }
            foreach ($cert in $expiringCerts) {
                try {
                    # Extract dates and check expiration
                    $datePattern = '\d{1,2}/\d{1,2}/\d{4}'
                    $dates = [regex]::Matches($cert, $datePattern)

                    foreach ($dateMatch in $dates) {
                        $certDate = [DateTime]::ParseExact($dateMatch.Value, "M/d/yyyy", $null)
                        $daysUntilExpiry = ($certDate - (Get-Date)).Days

                        if ($daysUntilExpiry -lt 0) {
                            $script:CriticalIssues += [PSCustomObject]@{
                                Category = "Certificates"
                                Type     = "Expired Certificate"
                                Finding  = "Certificate expired $([math]::Abs($daysUntilExpiry)) days ago: $cert"
                                Severity = "Critical"
                                Source   = $file.Name
                            }
                        } elseif ($daysUntilExpiry -lt 30) {
                            $script:Warnings += [PSCustomObject]@{
                                Category = "Certificates"
                                Type     = "Expiring Certificate"
                                Finding  = "Certificate expires in $daysUntilExpiry days: $cert"
                                Severity = "Warning"
                                Source   = $file.Name
                            }
                        }
                    }
                } catch {
                    # Date parsing failed, log as info
                    $script:DetailedFindings += [PSCustomObject]@{
                        Category = "Certificates"
                        Type     = "Certificate Info"
                        Finding  = $cert
                        Severity = "Info"
                        Source   = $file.Name
                    }
                }
            }

            # Look for self-signed certificates
            $selfSigned = $content | Where-Object { $_ -like "*self-signed*" -or $_ -like "*self signed*" }
            if ($selfSigned) {
                $script:Warnings += [PSCustomObject]@{
                    Category = "Certificates"
                    Type     = "Self-Signed Certificate"
                    Finding  = "Self-signed certificates detected - consider using CA-issued certificates for production"
                    Severity = "Warning"
                    Source   = $file.Name
                }
            }

            # Look for RDP-specific certificates
            $rdpCerts = $content | Where-Object { $_ -like "*Remote Desktop*" -or $_ -like "*RDP*" -or $_ -like "*Terminal*" }
            foreach ($rdpCert in $rdpCerts) {
                $script:DetailedFindings += [PSCustomObject]@{
                    Category = "Certificates"
                    Type     = "RDP Certificate"
                    Finding  = $rdpCert
                    Severity = "Info"
                    Source   = $file.Name
                }
            }
        }

        Write-ColorOutput -Message "Certificate analysis completed" -Color Green

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error analyzing certificates: $($_.Exception.Message)" -Color Red
    }
}

function Get-MSRDHtmlReportAnalysis {
    <#
    .SYNOPSIS
    Parses and analyzes HTML diagnostic reports generated by MSRD-Collect.
    #>
    try {
        if (-not $script:AnalyzeHtmlReports) {
            Write-Verbose "HTML report analysis disabled"
            return
        }

        Write-ColorOutput -Message "Analyzing HTML diagnostic reports..." -Color Cyan

        $htmlReports = Get-ChildItem -Path $script:MSRDOutputPath -Filter "*MSRD-Diag*.html" -ErrorAction SilentlyContinue

        if ($htmlReports.Count -eq 0) {
            Write-ColorOutput -Message "Warning: No HTML diagnostic reports found" -Color Yellow
            return
        }

        foreach ($htmlReport in $htmlReports) {
            Write-Verbose "Processing HTML report: $($htmlReport.Name)"

            try {
                $htmlContent = Get-Content -Path $htmlReport.FullName -Raw -ErrorAction SilentlyContinue

                # Extract table data from HTML - look for actual diagnostic issues, not formatting
                $tablePattern = '<table[^>]*class="[^"]*diag[^"]*"[^>]*>(.*?)</table>'
                $tables = [regex]::Matches($htmlContent, $tablePattern, [System.Text.RegularExpressions.RegexOptions]::Singleline)

                foreach ($table in $tables) {
                    $tableHtml = $table.Groups[1].Value

                    # Look for actual error indicators, not just red formatting
                    if ($tableHtml -like "*bgcolor='#FF0000'*" -or $tableHtml -like "*color: red*" -or $tableHtml -like "*class='error'*") {
                        # Extract row content for actual errors
                        $rowPattern = '<tr[^>]*>(.*?)</tr>'
                        $rows = [regex]::Matches($tableHtml, $rowPattern, [System.Text.RegularExpressions.RegexOptions]::Singleline)

                        foreach ($row in $rows) {
                            $rowHtml = $row.Groups[1].Value
                            # Skip header rows and styling-only rows
                            if ($rowHtml -notlike "*<th*" -and
                                ($rowHtml -like "*bgcolor='#FF0000'*" -or $rowHtml -like "*color: red*" -or $rowHtml -like "*class='error'*")) {

                                # Extract meaningful cell text
                                $cellPattern = '<td[^>]*>(.*?)</td>'
                                $cells = [regex]::Matches($rowHtml, $cellPattern, [System.Text.RegularExpressions.RegexOptions]::Singleline)

                                # Must have at least 2 cells for meaningful data
                                if ($cells.Count -gt 1) {
                                    $cellTexts = @()
                                    foreach ($cell in $cells) {
                                        $cellText = $cell.Groups[1].Value -replace '<[^>]+>', '' -replace '&nbsp;', ' ' -replace '\s+', ' '
                                        if ($cellText.Trim() -and $cellText.Trim() -ne '' -and $cellText.Trim().Length -gt 3) {
                                            $cellTexts += $cellText.Trim()
                                        }
                                    }

                                    if ($cellTexts.Count -gt 0) {
                                        $combinedText = $cellTexts -join ' | '
                                        # Filter out noise - only include meaningful diagnostic information
                                        if ($combinedText -notlike "*&#*" -and
                                            $combinedText -notlike "*Service*Stopped*Manual*" -and
                                            $combinedText.Length -gt 20) {

                                            $script:CriticalIssues += [PSCustomObject]@{
                                                Category = "HTML Report"
                                                Type     = "Diagnostic Finding"
                                                Finding  = $combinedText
                                                Severity = "Critical"
                                                Source   = $htmlReport.Name
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                # Look for specific diagnostic patterns in HTML
                $diagnosticPatterns = @{
                    "Service.*stopped"     = "Service Status Issue"
                    "Registry.*missing"    = "Registry Configuration"
                    "Port.*blocked"        = "Network Connectivity"
                    "Certificate.*invalid" = "Certificate Issue"
                    "Permission.*denied"   = "Security Permissions"
                }

                foreach ($pattern in $diagnosticPatterns.Keys) {
                    $patternMatches = [regex]::Matches($htmlContent, $pattern, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
                    foreach ($match in $patternMatches) {
                        $context = $htmlContent.Substring([Math]::Max(0, $match.Index - 100), [Math]::Min(200, $htmlContent.Length - [Math]::Max(0, $match.Index - 100)))
                        $cleanContext = $context -replace '<[^>]+>', '' -replace '&nbsp;', ' ' -replace '\s+', ' '

                        $script:Warnings += [PSCustomObject]@{
                            Category = "HTML Report"
                            Type     = $diagnosticPatterns[$pattern]
                            Finding  = "Diagnostic pattern detected: $cleanContext"
                            Severity = "Warning"
                            Source   = $htmlReport.Name
                        }
                    }
                }

                $script:DetailedFindings += [PSCustomObject]@{
                    Category = "HTML Report"
                    Type     = "Analysis"
                    Finding  = "Processed HTML diagnostic report: $($htmlReport.Name)"
                    Severity = "Info"
                    Source   = $htmlReport.Name
                }

            } catch {
                Write-ColorOutput -Message "Warning: Could not process HTML report $($htmlReport.Name): $($_.Exception.Message)" -Color Yellow
            }
        }

        Write-ColorOutput -Message "HTML report analysis completed" -Color Green

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error analyzing HTML reports: $($_.Exception.Message)" -Color Red
    }
}

function Get-RecommendationEngine {
    <#
    .SYNOPSIS
    Generates comprehensive recommendations based on identified issues.
    #>
    try {
        Write-ColorOutput -Message "Generating recommendations..." -Color Cyan

        # Analyze critical issues and generate recommendations
        foreach ($issue in $script:CriticalIssues) {
            switch ($issue.Finding) {
                { $_ -like "*fDenyTSConnections=1*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Enable Terminal Services by setting fDenyTSConnections to 0 in registry or using 'Enable-PSRemoting'"
                        Priority       = "High"
                        Category       = "Configuration"
                        PowerShellCmd  = "Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name 'fDenyTSConnections' -Value 0"
                    }
                }
                { $_ -like "*port 3389*not listening*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Start Terminal Services service and verify RDP is enabled in System Properties"
                        Priority       = "High"
                        Category       = "Network"
                        PowerShellCmd  = "Start-Service TermService; Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name 'fDenyTSConnections' -Value 0"
                    }
                }
                { $_ -like "*firewall rules are disabled*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Enable Remote Desktop firewall rules"
                        Priority       = "High"
                        Category       = "Firewall"
                        PowerShellCmd  = "Enable-NetFirewallRule -DisplayGroup 'Remote Desktop'"
                    }
                }
                { $_ -like "*service*stopped*" } {
                    $serviceName = ($issue.Finding -split " ")[0]
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Start the $serviceName service and set to automatic startup"
                        Priority       = "High"
                        Category       = "Services"
                        PowerShellCmd  = "Start-Service -Name '$serviceName'; Set-Service -Name '$serviceName' -StartupType Automatic"
                    }
                }
                { $_ -like "*memory usage*" -and $_ -like "*90*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Critical memory usage detected. Restart services, close unnecessary applications, or add more RAM"
                        Priority       = "High"
                        Category       = "Performance"
                        PowerShellCmd  = "Get-Process | Sort-Object WorkingSet -Descending | Select-Object -First 10"
                    }
                }
                { $_ -like "*AVD Agent*error*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Reinstall AVD Agent and ensure network connectivity to AVD services"
                        Priority       = "High"
                        Category       = "AVD"
                        PowerShellCmd  = "# Download and reinstall AVD Agent from Azure portal or Microsoft documentation"
                    }
                }
                { $_ -like "*FSLogix*" -and $_ -like "*Event ID 26*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Disable DisablePersonalDirChange group policy or configure folder redirection exceptions"
                        Priority       = "High"
                        Category       = "FSLogix"
                        PowerShellCmd  = "# Check Group Policy: Computer Configuration > Administrative Templates > System > Folder Redirection"
                    }
                }
                { $_ -like "*Profile*VHD*" -and $_ -like "*mounting failed*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Check FSLogix profile container VHD integrity and network share connectivity"
                        Priority       = "High"
                        Category       = "FSLogix"
                        PowerShellCmd  = "Test-NetConnection -ComputerName <profile-share-server> -Port 445"
                    }
                }
                { $_ -like "*Certificate*expired*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Renew expired certificates and update RDP configuration"
                        Priority       = "High"
                        Category       = "Security"
                        PowerShellCmd  = "Get-ChildItem Cert:\LocalMachine\My | Where-Object { $_.NotAfter -lt (Get-Date) }"
                    }
                }
                { $_ -like "*Unsupported operating system*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $issue.Finding
                        Recommendation = "Upgrade to a supported Windows version (Windows 10/11 or Windows Server 2016+)"
                        Priority       = "Critical"
                        Category       = "System"
                        PowerShellCmd  = "Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion"
                    }
                }
            }
        }

        # Generate general recommendations based on warnings
        foreach ($warning in $script:Warnings) {
            switch ($warning.Finding) {
                { $_ -like "*Network Level Authentication is disabled*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $warning.Finding
                        Recommendation = "Enable Network Level Authentication for improved security"
                        Priority       = "Medium"
                        Category       = "Security"
                        PowerShellCmd  = "Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name 'UserAuthentication' -Value 1"
                    }
                }
                { $_ -like "*memory usage*" -and $_ -like "*80*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $warning.Finding
                        Recommendation = "Monitor memory usage and consider optimization or adding more RAM"
                        Priority       = "Medium"
                        Category       = "Performance"
                        PowerShellCmd  = "Get-Counter '\Memory\Available MBytes' -SampleInterval 5 -MaxSamples 12"
                    }
                }
                { $_ -like "*disconnected sessions*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $warning.Finding
                        Recommendation = "Configure session timeout policies to automatically log off disconnected sessions"
                        Priority       = "Medium"
                        Category       = "Session Management"
                        PowerShellCmd  = "qwinsta; # Use 'logoff <session-id>' to manually clean up sessions"
                    }
                }
                { $_ -like "*Certificate*expires*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $warning.Finding
                        Recommendation = "Plan certificate renewal before expiration"
                        Priority       = "Medium"
                        Category       = "Security"
                        PowerShellCmd  = "Get-ChildItem Cert:\LocalMachine\My | Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) }"
                    }
                }
                { $_ -like "*Self-signed*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $warning.Finding
                        Recommendation = "Replace self-signed certificates with CA-issued certificates for production environments"
                        Priority       = "Medium"
                        Category       = "Security"
                        PowerShellCmd  = "# Request certificate from internal CA or public CA provider"
                    }
                }
                { $_ -like "*Low total memory*" } {
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $warning.Finding
                        Recommendation = "Increase system RAM to at least 8GB for optimal RDS/AVD performance"
                        Priority       = "Medium"
                        Category       = "Hardware"
                        PowerShellCmd  = "(Get-CimInstance Win32_PhysicalMemory | Measure-Object -Property capacity -Sum).sum /1gb"
                    }
                }
                { $_ -like "*Software Conflict*" } {
                    $software = ($warning.Finding -split ":")[1].Trim()
                    $script:Recommendations += [PSCustomObject]@{
                        Issue          = $warning.Finding
                        Recommendation = "Remove or disable conflicting remote access software: $software"
                        Priority       = "Medium"
                        Category       = "Software"
                        PowerShellCmd  = "Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -like '*$software*' }"
                    }
                }
            }
        }

        # Add general best practice recommendations
        if ($script:CriticalIssues.Count -eq 0 -and $script:Warnings.Count -eq 0) {
            $script:Recommendations += [PSCustomObject]@{
                Issue          = "No critical issues detected"
                Recommendation = "Continue monitoring system health and apply security updates regularly"
                Priority       = "Low"
                Category       = "Maintenance"
                PowerShellCmd  = "Get-WindowsUpdate -Install -AcceptAll -AutoReboot"
            }
        }

        # Performance optimization recommendations based on findings
        if ($script:AVDFindings.Count -gt 0) {
            $script:Recommendations += [PSCustomObject]@{
                Issue          = "AVD environment detected"
                Recommendation = "Implement AVD-specific monitoring and optimization policies"
                Priority       = "Low"
                Category       = "AVD Optimization"
                PowerShellCmd  = "# Configure AVD-specific group policies and monitoring solutions"
            }
        }

        if ($script:FSLogixFindings.Count -gt 0) {
            $script:Recommendations += [PSCustomObject]@{
                Issue          = "FSLogix profiles detected"
                Recommendation = "Monitor FSLogix profile container sizes and implement cleanup policies"
                Priority       = "Low"
                Category       = "Profile Management"
                PowerShellCmd  = "# Configure FSLogix cleanup tasks and profile size monitoring"
            }
        }

        Write-ColorOutput -Message "Generated $($script:Recommendations.Count) recommendations" -Color Green

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error generating recommendations: $($_.Exception.Message)" -Color Red
    }
}

function Export-AnalysisReport {
    <#
    .SYNOPSIS
    Exports comprehensive analysis results to formatted reports.
    #>
    try {
        Write-ColorOutput -Message "Generating comprehensive analysis reports..." -Color Cyan

        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        $reportFileName = "MSRD-Analysis-Report-$($script:ComputerName)-$timestamp.txt"
        $reportPath = Join-Path -Path $script:ReportPath -ChildPath $reportFileName

        # Generate comprehensive report
        $reportContent = @"
=============================================================================
MSRD-Collect Comprehensive Analysis Report
=============================================================================
Generated: $((Get-Date -AsUTC).ToString('yyyy-MM-dd HH:mm:ss')) UTC
Target System: $($script:ComputerName)
Analysis Period: $($script:DaysToAnalyze) days
Source Directory: $($script:MSRDOutputPath)
=============================================================================

EXECUTIVE SUMMARY
=================
Critical Issues Found: $($script:CriticalIssues.Count)
Warnings: $($script:Warnings.Count)
Recommendations: $($script:Recommendations.Count)
AVD-Specific Findings: $($script:AVDFindings.Count)
FSLogix Profile Findings: $($script:FSLogixFindings.Count)
Security Findings: $($script:SecurityFindings.Count)
Performance Issues: $($script:PerformanceIssues.Count)
Storage/Disk Findings: $($script:DiskFindings.Count)

SYSTEM HEALTH STATUS
====================
"@

        if ($script:CriticalIssues.Count -eq 0) {
            $reportContent += "[PASS] No critical issues detected`n"
        } else {
            $reportContent += "[FAIL] $($script:CriticalIssues.Count) critical issues require immediate attention`n"
        }

        if ($script:Warnings.Count -eq 0) {
            $reportContent += "[PASS] No warnings detected`n"
        } else {
            $reportContent += "[WARN] $($script:Warnings.Count) warnings need review`n"
        }

        $reportContent += "`n=============================================================================`n"

        # Critical Issues Section
        $reportContent += "`nCRITICAL ISSUES ($($script:CriticalIssues.Count))`n"
        $reportContent += "===============`n"

        if ($script:CriticalIssues.Count -eq 0) {
            $reportContent += "No critical issues detected.`n"
        } else {
            $categoryGroups = $script:CriticalIssues | Group-Object Category
            foreach ($group in $categoryGroups) {
                $reportContent += "`n[$($group.Name)] - $($group.Count) issue(s):`n"
                foreach ($issue in $group.Group) {
                    $reportContent += "  - $($issue.Finding)"
                    if ($issue.Source) {
                        $reportContent += " (Source: $($issue.Source))"
                    }
                    $reportContent += "`n"
                }
            }
        }

        # Warnings Section
        $reportContent += "`nWARNINGS ($($script:Warnings.Count))`n"
        $reportContent += "========`n"

        if ($script:Warnings.Count -eq 0) {
            $reportContent += "No warnings detected.`n"
        } else {
            $categoryGroups = $script:Warnings | Group-Object Category
            foreach ($group in $categoryGroups) {
                $reportContent += "`n[$($group.Name)] - $($group.Count) warning(s):`n"
                foreach ($warning in $group.Group) {
                    $reportContent += "  - $($warning.Finding)"
                    if ($warning.Source) {
                        $reportContent += " (Source: $($warning.Source))"
                    }
                    $reportContent += "`n"
                }
            }
        }

        # Recommendations Section
        $reportContent += "`nRECOMMENDATIONS ($($script:Recommendations.Count))`n"
        $reportContent += "===============`n"

        if ($script:Recommendations.Count -eq 0) {
            $reportContent += "No specific recommendations at this time.`n"
        } else {
            $priorityGroups = $script:Recommendations | Group-Object Priority
            $priorityOrder = @("Critical", "High", "Medium", "Low")

            foreach ($priority in $priorityOrder) {
                $priorityGroup = $priorityGroups | Where-Object { $_.Name -eq $priority }
                if ($priorityGroup) {
                    $reportContent += "`n$priority Priority ($($priorityGroup.Count)):`n"
                    foreach ($rec in $priorityGroup.Group) {
                        $reportContent += "`nIssue: $($rec.Issue)`n"
                        $reportContent += "Recommendation: $($rec.Recommendation)`n"
                        $reportContent += "Category: $($rec.Category)`n"
                        if ($rec.PowerShellCmd) {
                            $reportContent += "PowerShell Command: $($rec.PowerShellCmd)`n"
                        }
                        $reportContent += "---`n"
                    }
                }
            }
        }

        # Storage and Disk Findings Section
        $reportContent += "`nSTORAGE AND DISK FINDINGS ($($script:DiskFindings.Count))`n"
        $reportContent += "==========================`n"
        if ($script:DiskFindings.Count -eq 0) {
            $reportContent += "No storage or disk findings detected.`n"
        } else {
            foreach ($f in $script:DiskFindings) {
                $reportContent += " - $f`n"
            }
        }

        # AVD-Specific Section
        if ($script:IncludeAVDAnalysis -and $script:AVDFindings.Count -gt 0) {
            $reportContent += "`nAZURE VIRTUAL DESKTOP FINDINGS ($($script:AVDFindings.Count))`n"
            $reportContent += "===============================`n"
            foreach ($finding in $script:AVDFindings) {
                $reportContent += "[$($finding.Type)] $($finding.Finding)"
                if ($finding.Source) {
                    $reportContent += " (Source: $($finding.Source))"
                }
                $reportContent += "`n"
            }
        }

        # FSLogix Section
        if ($script:IncludeFSLogixAnalysis -and $script:FSLogixFindings.Count -gt 0) {
            $reportContent += "`nFSLOGIX PROFILE FINDINGS ($($script:FSLogixFindings.Count))`n"
            $reportContent += "=========================`n"
            foreach ($finding in $script:FSLogixFindings) {
                $reportContent += "[$($finding.Type)] $($finding.Finding)"
                if ($finding.Source) {
                    $reportContent += " (Source: $($finding.Source))"
                }
                $reportContent += "`n"
            }
        }

        # Detailed Findings Section
        if ($script:IncludeDetailedLogs -and $script:DetailedFindings.Count -gt 0) {
            $reportContent += "`nDETAILED FINDINGS ($($script:DetailedFindings.Count))`n"
            $reportContent += "=================`n"
            $categoryGroups = $script:DetailedFindings | Group-Object Category
            foreach ($group in $categoryGroups) {
                $reportContent += "`n[$($group.Name)] - $($group.Count) finding(s):`n"
                foreach ($finding in $group.Group) {
                    $reportContent += "  - [$($finding.Type)] $($finding.Finding)"
                    if ($finding.Source) {
                        $reportContent += " (Source: $($finding.Source))"
                    }
                    $reportContent += "`n"
                }
            }
        }

        # Optional: Storage and Disk Detailed Events (Top 25)
        if ($script:DiskEventDetails.Count -gt 0) {
            $reportContent += "`nSTORAGE AND DISK EVENT DETAILS (Top 25)`n"
            $reportContent += "=====================================`n"
            $top = $script:DiskEventDetails | Sort-Object -Property TimeCreatedUtc -Descending | Select-Object -First 25
            foreach ($d in $top) {
                $summary = "[$($d.LogName)] Id=$($d.Id) TimeUtc=$($d.TimeCreatedUtc)"
                if ($d.ServerName -or $d.ShareName) { $summary += " Server=$($d.ServerName) Share=$($d.ShareName)" }
                if ($d.Path) { $summary += " Path=$($d.Path)" }
                if ($d.Device) { $summary += " Device=$($d.Device)" }
                if ($d.Volume) { $summary += " Volume=$($d.Volume)" }
                if ($d.Status) { $summary += " Status=$($d.Status)" }
                $reportContent += " - $summary`n"
            }
        }

        # Analysis Summary
        $reportContent += "`n=============================================================================`n"
        $reportContent += "ANALYSIS SUMMARY`n"
        $reportContent += "================`n"
        $reportContent += "Directories Analyzed:`n"
        $reportContent += "  - EventLogs: $(if ($script:EventLogsPath) { 'Yes' } else { 'No' })`n"
        $reportContent += "  - Registry: $(if ($script:RegistryPath) { 'Yes' } else { 'No' })`n"
        $reportContent += "  - SystemInfo: $(if ($script:SystemInfoPath) { 'Yes' } else { 'No' })`n"
        $reportContent += "  - Networking: $(if ($script:NetworkingPath) { 'Yes' } else { 'No' })`n"
        $reportContent += "  - AVD: $(if ($script:AVDPath) { 'Yes' } else { 'No' })`n"
        $reportContent += "  - Profiles: $(if ($script:ProfilesPath) { 'Yes' } else { 'No' })`n"
        $reportContent += "  - Certificates: $(if ($script:CertificatesPath) { 'Yes' } else { 'No' })`n"
        $reportContent += "  - MDM: $(if ($script:MDMPath) { 'Yes' } else { 'No' })`n"
        $reportContent += "`nAnalysis Modules:`n"
        $reportContent += "  - HTML Reports: $(if ($script:AnalyzeHtmlReports) { 'Enabled' } else { 'Disabled' })`n"
        $reportContent += "  - AVD Analysis: $(if ($script:IncludeAVDAnalysis) { 'Enabled' } else { 'Disabled' })`n"
        $reportContent += "  - FSLogix Analysis: $(if ($script:IncludeFSLogixAnalysis) { 'Enabled' } else { 'Disabled' })`n"
        $reportContent += "  - Detailed Logs: $(if ($script:IncludeDetailedLogs) { 'Enabled' } else { 'Disabled' })`n"

        $reportContent += "`n=============================================================================`n"
        $reportContent += "Generated by MSRD-Collect Analysis Tool v2.1.0`n"
        $reportContent += "Report Date: $((Get-Date -AsUTC).ToString('yyyy-MM-dd HH:mm:ss')) UTC`n"
        $reportContent += "=============================================================================`n"

        # Save report
        $reportContent | Out-File -FilePath $reportPath -Encoding UTF8 -Force
        Write-ColorOutput -Message "Analysis report saved: $reportPath" -Color Green

        # Export to CSV if requested
        if ($script:ExportToCSV) {
            $csvFileName = "MSRD-Analysis-Data-$($script:ComputerName)-$timestamp.csv"
            $csvPath = Join-Path -Path $script:ReportPath -ChildPath $csvFileName

            $allFindings = @()

            # Add all findings with source tracking
            $allFindings += $script:CriticalIssues | Select-Object *, @{ Name='FindingType';Expression= { 'Critical Issue' } }
            $allFindings += $script:Warnings | Select-Object *, @{ Name='FindingType';Expression= { 'Warning' } }
            $allFindings += $script:AVDFindings | Select-Object *, @{ Name='FindingType';Expression= { 'AVD Finding' } }
            $allFindings += $script:FSLogixFindings | Select-Object *, @{ Name='FindingType';Expression= { 'FSLogix Finding' } }

            # Include disk findings (convert strings to objects for CSV)
            if ($script:DiskFindings.Count -gt 0) {
                $diskForCsv = $script:DiskFindings | ForEach-Object {
                    [PSCustomObject]@{
                        Category    = 'Disk'
                        Type        = 'Summary'
                        Finding     = $_
                        Severity    = 'Info'
                        Source      = 'DiskAnalysis'
                        FindingType = 'Disk Finding'
                    }
                }
                $allFindings += $diskForCsv
            }

            if ($script:IncludeDetailedLogs) {
                $allFindings += $script:DetailedFindings | Select-Object *, @{ Name='FindingType';Expression= { 'Detailed Finding' } }
            }

            $allFindings | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8
            Write-ColorOutput -Message "CSV data exported: $csvPath" -Color Green

            # Export recommendations to separate CSV
            if ($script:Recommendations.Count -gt 0) {
                $recCsvFileName = "MSRD-Recommendations-$($script:ComputerName)-$timestamp.csv"
                $recCsvPath = Join-Path -Path $script:ReportPath -ChildPath $recCsvFileName
                $script:Recommendations | Export-Csv -Path $recCsvPath -NoTypeInformation -Encoding UTF8
                Write-ColorOutput -Message "Recommendations CSV exported: $recCsvPath" -Color Green
            }

            # Export Disk Event Details to CSV
            if ($script:DiskEventDetails.Count -gt 0) {
                $diskCsvFileName = "MSRD-DiskEvents-$($script:ComputerName)-$timestamp.csv"
                $diskCsvPath = Join-Path -Path $script:ReportPath -ChildPath $diskCsvFileName
                $script:DiskEventDetails | Export-Csv -Path $diskCsvPath -NoTypeInformation -Encoding UTF8
                Write-ColorOutput -Message "Disk event details CSV exported: $diskCsvPath" -Color Green
            }
        }

        return $reportPath

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Error exporting analysis report: $($_.Exception.Message)" -Color Red
        throw
    }
}

function Invoke-MSRDAnalysis {
    <#
    .SYNOPSIS
    Main analysis orchestration function for comprehensive MSRD-Collect output analysis.
    #>
    try {
        Write-ColorOutput -Message "Starting comprehensive MSRD-Collect output analysis..." -Color Green
        Write-ColorOutput -Message "Target directory: $script:MSRDOutputPath" -Color White
        Write-ColorOutput -Message "Analysis period: $script:DaysToAnalyze days" -Color White
        Write-ColorOutput -Message "Computer: $script:ComputerName" -Color White

        # Initialize environment
        Initialize-AnalysisEnvironment

        # Core analysis modules
        Write-ColorOutput -Message "`nRunning core analysis modules..." -Color Cyan
        Get-MSRDSystemInfo
        Get-MSRDEventLog
        Get-MSRDRegistryAnalysis
        Get-MSRDNetworkAnalysis

        # Advanced analysis modules
        Write-ColorOutput -Message "`nRunning advanced analysis modules..." -Color Cyan

        if ($script:IncludeAVDAnalysis) {
            Get-MSRDAVDAnalysis
        }

        if ($script:IncludeFSLogixAnalysis) {
            Get-MSRDFSLogixAnalysis
        }

        # New: Storage and Disk Health
        Get-MSRDDiskAnalysis

        Get-MSRDCertificateAnalysis

        if ($script:AnalyzeHtmlReports) {
            Get-MSRDHtmlReportAnalysis
        }

        # Generate recommendations
        Write-ColorOutput -Message "`nGenerating recommendations..." -Color Cyan
        Get-RecommendationEngine

        # Export results
        Write-ColorOutput -Message "`nExporting analysis results..." -Color Cyan
        $reportPath = Export-AnalysisReport

        # Display comprehensive summary
        Write-ColorOutput -Message "`n" -Color White
        Write-ColorOutput -Message "==================================================" -Color Green
        Write-ColorOutput -Message "    MSRD-COLLECT ANALYSIS COMPLETE" -Color Green
        Write-ColorOutput -Message "==================================================" -Color Green
        Write-ColorOutput -Message "System Analyzed: $script:ComputerName" -Color White
        Write-ColorOutput -Message "Analysis Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -Color White
        Write-ColorOutput -Message "--------------------------------------------------" -Color DarkGray

        # Critical issues summary
        if ($script:CriticalIssues.Count -gt 0) {
            Write-ColorOutput -Message "[FAIL] Critical Issues: $($script:CriticalIssues.Count)" -Color Red
            $criticalByCategory = $script:CriticalIssues | Group-Object Category
            foreach ($group in $criticalByCategory) {
                Write-ColorOutput -Message "   - $($group.Name): $($group.Count)" -Color Red
            }
        } else {
            Write-ColorOutput -Message "[PASS] Critical Issues: 0" -Color Green
        }

        # Warnings summary
        if ($script:Warnings.Count -gt 0) {
            Write-ColorOutput -Message "[WARN] Warnings: $($script:Warnings.Count)" -Color Yellow
            $warningsByCategory = $script:Warnings | Group-Object Category
            foreach ($group in $warningsByCategory) {
                Write-ColorOutput -Message "   - $($group.Name): $($group.Count)" -Color Yellow
            }
        } else {
            Write-ColorOutput -Message "[PASS] Warnings: 0" -Color Green
        }

        # Advanced findings summary
        if ($script:AVDFindings.Count -gt 0) {
            Write-ColorOutput -Message "[AVD] AVD Findings: $($script:AVDFindings.Count)" -Color Cyan
        }

        if ($script:FSLogixFindings.Count -gt 0) {
            Write-ColorOutput -Message "[FSLogix] FSLogix Findings: $($script:FSLogixFindings.Count)" -Color Cyan
        }

        Write-ColorOutput -Message "[INFO] Recommendations: $($script:Recommendations.Count)" -Color Cyan
        Write-ColorOutput -Message "--------------------------------------------------" -Color DarkGray

        # Priority recommendations
        if ($script:Recommendations.Count -gt 0) {
            $highPriorityRecs = $script:Recommendations | Where-Object { $_.Priority -eq "High" -or $_.Priority -eq "Critical" }
            if ($highPriorityRecs.Count -gt 0) {
                Write-ColorOutput -Message "[URGENT] High Priority Actions Required:" -Color Red
                foreach ($rec in $highPriorityRecs | Select-Object -First 3) {
                    Write-ColorOutput -Message "   - $($rec.Recommendation)" -Color Red
                }
                if ($highPriorityRecs.Count -gt 3) {
                    Write-ColorOutput -Message "   - ... and $($highPriorityRecs.Count - 3) more (see full report)" -Color Red
                }
            }
        }

        Write-ColorOutput -Message "--------------------------------------------------" -Color DarkGray
        Write-ColorOutput -Message "[REPORT] Full Report: $reportPath" -Color White

        if ($script:ExportToCSV) {
            Write-ColorOutput -Message "[CSV] CSV Data: $(Split-Path $reportPath -Parent)" -Color White
        }

        Write-ColorOutput -Message "==================================================" -Color Green

        # Analysis status determination
        $exitCode = 0
        if ($script:CriticalIssues.Count -gt 0) {
            $exitCode = 1
            Write-ColorOutput -Message "[WARN] Analysis completed with critical issues requiring immediate attention" -Color Red
        } elseif ($script:Warnings.Count -gt 0) {
            Write-ColorOutput -Message "[INFO] Analysis completed with warnings that should be reviewed" -Color Yellow
        } else {
            Write-ColorOutput -Message "[PASS] Analysis completed successfully with no critical issues detected" -Color Green
        }

        return $exitCode

    } catch {
        Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Analysis failed: $($_.Exception.Message)" -Color Red
        return 1
    } finally {
        if (Get-Command Stop-Transcript -ErrorAction SilentlyContinue) {
            Stop-Transcript -ErrorAction SilentlyContinue
        }
    }
}

# Main execution
try {
    $exitCode = Invoke-MSRDAnalysis
    exit $exitCode
} catch {
    Write-ColorOutput -Message "[SYSTEM ERROR DETECTED] Script execution failed: $($_.Exception.Message)" -Color Red
    exit 1
}
